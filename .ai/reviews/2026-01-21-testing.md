# Testing Code Review

**Date:** 2026-01-21
**Scope:** Test quality, coverage, and production code testability
**Status:** Open

## Summary

The ajira project has a solid testing foundation with comprehensive unit tests for most packages. Tests follow Go conventions, use proper mocking with httptest, and achieve good coverage in core packages. Key areas for improvement include increasing CLI package coverage, adding t.Parallel() for faster test execution, and introducing integration tests.

## Coverage Analysis

| Package | Coverage | Assessment |
|---------|----------|------------|
| cmd/ajira | 0.0% | Expected (thin entry point) |
| internal/api | 63.1% | Good |
| internal/cli | 28.1% | Needs improvement |
| internal/config | 96.9% | Excellent |
| internal/converter | 89.6% | Excellent |
| internal/jira | 79.1% | Good |
| internal/width | 100.0% | Excellent |

### Coverage Summary

- **Total packages with tests:** 6
- **Packages above 80%:** 3 (config, converter, width)
- **Packages needing attention:** cli (28.1%)

## Findings

### 1. Test Structure (Strengths)

**Table-driven tests used effectively:**
- `exitcodes_test.go:11-92` - Excellent table-driven tests for exit code mapping
- `open_test.go:5-55` - Good table-driven URL tests
- `width_test.go` - Comprehensive table-driven tests for Unicode handling
- `sprint_test.go:226-243` - Table-driven for date formatting

**Subtests with t.Run():**
- Tests consistently use `t.Run()` for subtest organisation
- Test names are descriptive and indicate what's being tested

**HTTP mocking:**
- Extensive use of `httptest.NewServer` for API testing
- Mock servers properly validate request methods, paths, and bodies
- Proper cleanup with `defer server.Close()`

### 2. Test Structure (Improvements Needed)

**F-001: Missing t.Parallel()**
- **Severity:** Low
- **Location:** All test files
- **Details:** No tests use `t.Parallel()` to enable concurrent execution
- **Recommendation:** Add `t.Parallel()` to independent tests:
  ```go
  func TestFoo(t *testing.T) {
      t.Parallel()
      // ...
  }
  ```

**F-002: Global state in CLI tests**
- **Severity:** Medium
- **Location:** `cli/issue_test.go`, `cli/epic_test.go`
- **Details:** Tests modify package-level variables (`project`, `issueListStatus`, etc.)
  ```go
  // From issue_test.go:357-371
  func resetIssueListFlags() {
      issueListQuery = ""
      issueListStatus = ""
      // ...
  }
  ```
- **Impact:** Tests must run sequentially; can cause flaky tests if not properly reset
- **Recommendation:** Refactor to pass state explicitly or use test fixtures

### 3. Coverage Gaps

**F-003: CLI package low coverage (28.1%)**
- **Severity:** Medium
- **Location:** `internal/cli/`
- **Details:** The CLI package has the lowest coverage. Missing tests for:
  - Most Cobra command RunE functions
  - Output formatting functions
  - stdin reading logic
  - Error message formatting
- **Recommendation:** Add integration tests or test the underlying functions called by commands

**F-004: No cmd/ajira tests**
- **Severity:** Low
- **Location:** `cmd/ajira/`
- **Details:** Main entry point has no tests
- **Recommendation:** This is acceptable for thin entry points; ensure CLI tests cover command wiring

### 4. Test Helpers

**Strengths:**
- `testConfig()` helper functions are defined locally in test files
- Common mock server patterns are repeated but consistent

**F-005: Missing t.Helper() on some helpers**
- **Severity:** Low
- **Location:** Various test files
- **Details:** Some helper functions don't call `t.Helper()`
- **Recommendation:** Add `t.Helper()` to all test helper functions:
  ```go
  func testConfig(serverURL string) *config.Config {
      // This isn't a testing.T helper, so no change needed
  }

  func assertEqual(t *testing.T, got, want int) {
      t.Helper()  // ADD THIS
      if got != want {
          t.Errorf("got %d, want %d", got, want)
      }
  }
  ```

### 5. Fixtures and Test Data

**Strengths:**
- `t.TempDir()` used correctly in `issue_test.go:1467-1471`
- Environment variable handling tested properly in `config_test.go`

**F-006: Environment variable tests could use t.Setenv()**
- **Severity:** Low
- **Location:** `config/config_test.go`
- **Details:** Uses manual `os.Setenv`/`os.Unsetenv` with defer
  ```go
  func setValidEnv() {
      os.Setenv("JIRA_BASE_URL", "...")
      // ...
  }
  ```
- **Recommendation:** Go 1.17+ supports `t.Setenv()` which auto-cleans up:
  ```go
  func TestLoad_Success(t *testing.T) {
      t.Setenv("JIRA_BASE_URL", "https://example.atlassian.net")
      t.Setenv("JIRA_EMAIL", "user@example.com")
      t.Setenv("JIRA_API_TOKEN", "test-token")
      // No cleanup needed
  }
  ```

### 6. Mocking and Fakes

**Strengths:**
- Interface-based design enables easy mocking
- `api.Client` is injectable
- HTTP responses are realistically structured

**F-007: No mock package or interface for Client**
- **Severity:** Low
- **Location:** `internal/api/`
- **Details:** Tests create real `api.Client` with mock server URLs
- **Recommendation:** Consider an interface if mocking becomes complex:
  ```go
  type HTTPClient interface {
      Get(ctx context.Context, path string) ([]byte, error)
      Post(ctx context.Context, path string, body []byte) ([]byte, error)
      // ...
  }
  ```

### 7. Race Detection

**Status:** PASS
- All tests pass with `-race` flag
- No data races detected

### 8. Testability of Production Code

**Strengths:**
- Functions accept `context.Context` for cancellation
- Dependencies are passed as parameters, not global
- `api.Client` is injectable
- Config is loaded once and passed around

**F-008: Package-level flag variables reduce testability**
- **Severity:** Medium
- **Location:** `internal/cli/` (various command files)
- **Details:** Cobra flags bind to package-level variables:
  ```go
  var (
      issueListQuery    string
      issueListStatus   string
      issueListType     string
      // ...
  )
  ```
- **Impact:** Tests must manually reset these between runs
- **Recommendation:** For better testability, consider:
  1. Accept a config struct in core functions
  2. Use Cobra's Viper integration
  3. Document reset requirements in test comments

### 9. Integration Tests

**F-009: No integration test suite**
- **Severity:** Low
- **Location:** N/A
- **Details:** All tests are unit tests with mocked HTTP
- **Recommendation:** Consider adding integration tests:
  ```go
  //go:build integration

  func TestRealJiraAPI(t *testing.T) {
      if os.Getenv("JIRA_BASE_URL") == "" {
          t.Skip("JIRA_BASE_URL not set")
      }
      // ...
  }
  ```

### 10. Benchmark Tests

**Status:** Present and good
- **Location:** `width/width_test.go:550-594`
- Benchmarks cover ASCII, CJK, emoji, and mixed strings
- Uses `b.N` correctly

**F-010: No benchmarks for API-related code**
- **Severity:** Low
- **Location:** `internal/api/`, `internal/converter/`
- **Recommendation:** Add benchmarks for:
  - Markdown to ADF conversion (complex parsing)
  - Large response handling

### 11. Fuzz Testing

**F-011: No fuzz tests**
- **Severity:** Low
- **Location:** N/A
- **Details:** Go 1.18+ native fuzzing not used
- **Recommendation:** Add fuzz tests for:
  - `internal/converter/` - Markdown parsing
  - `internal/width/` - Unicode width calculation
  ```go
  func FuzzMarkdownToADF(f *testing.F) {
      f.Add("Hello **world**")
      f.Add("# Heading\n\n- List item")
      f.Fuzz(func(t *testing.T, input string) {
          _, _ = MarkdownToADF(input)
      })
  }
  ```

### 12. Goroutine Leak Detection

**F-012: No goroutine leak detection**
- **Severity:** Low
- **Location:** N/A
- **Details:** goleak not used
- **Recommendation:** Consider adding for packages with concurrent code:
  ```go
  import "go.uber.org/goleak"

  func TestMain(m *testing.M) {
      goleak.VerifyTestMain(m)
  }
  ```

## Test Quality Assessment

### What the tests verify well:
1. API request/response handling
2. JQL query building
3. Error parsing and propagation
4. Date/time formatting
5. Unicode width calculation
6. Markdown/ADF conversion
7. Configuration validation

### What needs more testing:
1. CLI command execution flows
2. Output formatting
3. stdin reading paths
4. Edge cases in command argument parsing

## Recommendations

### High Priority

1. **Increase CLI coverage** - Add tests for command RunE functions or extract testable business logic

2. **Fix global state in tests** - Either:
   - Document reset requirements
   - Refactor to pass config explicitly
   - Use test fixtures

### Medium Priority

3. **Add t.Parallel()** - Enable parallel test execution for faster CI

4. **Use t.Setenv()** - Modernise environment variable tests

### Low Priority

5. **Add fuzz tests** for parsing code (converter, width)

6. **Add integration test suite** with build tag

7. **Add benchmarks** for converter package

## Positive Observations

- **Consistent patterns:** All test files follow similar structure
- **Good error testing:** Most functions test both success and error paths
- **Realistic mocks:** HTTP mocks return properly structured JSON
- **Edge cases considered:** Null handling, empty inputs, pagination
- **Race-safe:** All tests pass with `-race` flag
- **Benchmarks present:** Performance-critical code is benchmarked
