# Security Review

**Date**: 2026-01-21
**Reviewer**: AI Code Review (Claude)
**Scope**: Full security audit of Go source code

## Executive Summary

The ajira codebase demonstrates solid security practices overall. The application correctly enforces HTTPS, uses environment variables for secrets, implements proper HTTP client configuration with timeouts, and has no known vulnerabilities in dependencies. One medium-severity issue was identified related to command execution on Windows, along with several low-severity observations.

## Methodology

Review covered all security areas from the [Go Security Code Review checklist](../../.start/temp/task-golang-review-security.md):

- Input validation and injection prevention
- Authentication and secrets management
- Cryptography and TLS configuration
- HTTP client security
- Error handling for information disclosure
- Dependency security (govulncheck)
- Unsafe operations review

## Dependency Security

**govulncheck result**: No vulnerabilities found

```
$ govulncheck ./...
No vulnerabilities found.
```

Dependencies are appropriately pinned in `go.mod` and `go.sum` is committed.

## Findings

### SEC-001: Potential Command Injection on Windows (Medium)

**Location**: `internal/cli/open.go:107-122`

**Description**: The `openBrowser` function executes a shell command with a user-influenced URL. On Windows, the command uses `cmd /C start`:

```go
case "windows":
    cmd = exec.Command("cmd", "/C", "start", "", url)
```

The URL is constructed from the validated base URL plus a user-provided issue key or project key:

```go
url := IssueURL(cfg.BaseURL, args[0])  // args[0] comes from user
```

While the base URL is validated to use HTTPS, the issue key portion (`args[0]`) is not validated and could potentially contain shell metacharacters that `cmd.exe` interprets.

**Risk**: An attacker who controls the issue key argument could potentially inject shell commands on Windows systems.

**Mitigating Factors**:
- This is a CLI tool where the user explicitly provides arguments
- The base URL validation ensures the URL starts with a valid HTTPS prefix
- macOS and Linux use `open` and `xdg-open` which are less susceptible

**Recommendation**: Validate issue keys match expected format (e.g., `^[A-Z]+-\d+$`) before constructing URLs, or use URL escaping:

```go
import "net/url"

// Before constructing URL
escapedKey := url.PathEscape(key)
url := fmt.Sprintf("%s/browse/%s", baseURL, escapedKey)
```

---

### SEC-002: No File Size Limits on Input (Low)

**Location**: Multiple files using `os.ReadFile`:
- `internal/cli/issue_create.go:174`
- `internal/cli/issue_edit.go:155`
- `internal/cli/issue_comment.go:194, 215, 313`
- `internal/cli/epic_create.go:112`

**Description**: When reading description or comment content from files, there is no limit on file size:

```go
data, err := os.ReadFile(createFile)
```

**Risk**: A user could accidentally or intentionally specify a very large file, causing memory exhaustion.

**Recommendation**: Consider adding a reasonable size limit (e.g., 1MB) for input files, or use `io.LimitReader` when reading:

```go
const maxInputSize = 1 << 20 // 1MB
f, err := os.Open(filename)
if err != nil {
    return "", err
}
defer f.Close()
data, err := io.ReadAll(io.LimitReader(f, maxInputSize))
```

---

### SEC-003: Raw JQL Injection by Design (Low/Informational)

**Location**: `internal/cli/issue_list.go:232-235`

**Description**: The `--query` / `-q` flag allows users to pass raw JQL queries directly:

```go
if issueListQuery != "" {
    return issueListQuery
}
```

**Risk**: While this is intentional for power users, raw JQL can query data the user might not intend.

**Mitigating Factors**:
- JQL queries are subject to Jira's permission model
- This is documented CLI behaviour
- Users who provide raw JQL are expected to understand the implications

**Recommendation**: This is working as designed. Document that raw JQL bypasses the convenience filters' quoting.

---

### SEC-004: Path Traversal Not Applicable (Informational)

**Location**: All `os.ReadFile` calls

**Description**: File paths provided by users are used directly without sanitisation.

**Analysis**: This is a CLI tool where the user already has full file system access. Path traversal prevention would be unnecessary and could interfere with legitimate use cases (e.g., reading files from different directories).

**Recommendation**: No action required.

---

## Positive Security Practices

The following security best practices are correctly implemented:

### 1. HTTPS Enforcement

**Location**: `internal/config/config.go:69-81`

The base URL is validated to require HTTPS:

```go
func validateBaseURL(baseURL string) error {
    u, err := url.Parse(baseURL)
    if err != nil {
        return fmt.Errorf("invalid JIRA_BASE_URL: %w", err)
    }
    if u.Scheme != "https" {
        return errors.New("invalid JIRA_BASE_URL: must use https scheme")
    }
    // ...
}
```

### 2. Secrets via Environment Variables

**Location**: `internal/config/config.go:24-67`

API tokens and credentials are read from environment variables, not stored in files:

```go
cfg.APIToken = os.Getenv("JIRA_API_TOKEN")
```

### 3. HTTP Client Timeout

**Location**: `internal/api/client.go:47-49`

HTTP client has a configurable timeout (default 30s):

```go
httpClient: &http.Client{
    Timeout: cfg.HTTPTimeout,
},
```

### 4. No InsecureSkipVerify

The codebase does not disable TLS certificate verification. Default Go TLS configuration is used, which validates certificates.

### 5. No Unsafe Package Usage

No use of the `unsafe` package was found in the codebase.

### 6. No Weak Cryptography

No cryptographic operations are performed. UUIDs for task items use `github.com/google/uuid` which is appropriate.

### 7. Rate Limit Handling

**Location**: `internal/api/client.go:148-162`

Proper rate limit handling with exponential backoff:

```go
if resp.StatusCode == 429 && attempt < maxRetries {
    retryAfter := getRetryAfter(resp, attempt)
    // ...
    return c.doRequestWithRetry(ctx, method, path, body, attempt+1)
}
```

### 8. Context Propagation

All API calls properly propagate context for cancellation support.

### 9. Input Validation for Field Values

**Location**: `internal/jira/validate.go`

Priority, issue type, status, and link type values are validated against the Jira API before use:

```go
func ValidatePriority(ctx context.Context, client *api.Client, priority string) error {
    // Fetches valid options and validates input
}
```

### 10. JQL Value Quoting

**Location**: `internal/cli/issue_list.go:246-287`

User values in JQL queries are properly quoted:

```go
conditions = append(conditions, fmt.Sprintf("status = \"%s\"", issueListStatus))
```

## Summary Table

| ID | Finding | Severity | Status |
|----|---------|----------|--------|
| SEC-001 | Command injection risk in Windows browser open | Medium | Open |
| SEC-002 | No file size limits on input files | Low | Open |
| SEC-003 | Raw JQL injection by design | Low | By Design |
| SEC-004 | Path traversal not applicable | Info | N/A |

## Conclusion

The ajira codebase has a strong security posture for a CLI tool. The primary recommendation is to address SEC-001 by validating issue keys or URL-encoding user input before constructing URLs for browser opening. SEC-002 is a minor concern that could be addressed to improve robustness.

No critical or high-severity vulnerabilities were identified.
